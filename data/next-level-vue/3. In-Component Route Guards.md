# In-Component Route Guards

In this lesson we‚Äôll use **In-Component Route Guards** to implement our progress bar, and ensure it only renders the template once we‚Äôre done fetching data from our API.  The goal is to provide a better user experience.

## üõë Problem: When our API is slow our page looks broken

We need a way to account for a slow internet connection.  In the previous lesson, we showed how to implement a progress bar using Axios Interceptors.  In this lesson, we have a second potential solution so we‚Äôll be starting from scratch.  If you‚Äôre coding along with us you should know this isn‚Äôt the final solution we‚Äôre going to use in our example app, but it‚Äôs important to know how these Route Guards work.

## ‚òëÔ∏è Solution #2: In-Component Route Guards

We‚Äôll need to have **NProgress,** our progress bar library installed.  If you haven‚Äôt done that yet (from the last lesson) you‚Äôll want to run:

```
    $ npm install nprogress
```
and then add the CSS for NProgress:

üìÉ **/src/main.js**
```javascript
    import 'nprogress/nprogress.css'
```

----------

Vue gives us many different component lifecycle hooks, like `created()`, `mounted()`, `updated()`, etc.  When using Vue Router, we get three more component hooks called (**Route Navigation Guards**)[https://router.vuejs.org/guide/advanced/navigation-guards.html#in-component-guards]:

```javascript
    beforeRouteEnter(routeTo, routeFrom, next)
    beforeRouteUpdate(routeTo, routeFrom, next)
    beforeRouteLeave(routeTo, routeFrom, next)
```
We can define each of these inside our components, just like lifecycle hooks.  First, let‚Äôs learn about the Parameters:

  - **routeTo** - This refers to the route that is about to be navigated to.
  - **routeFrom -** This refers to the route that is about to be navigated away from.
  - **next -** This is a function that must be called in each of them to resolve the hook, and continue navigation.

Now let‚Äôs take a closer look at when each of these is called when it‚Äôs defined inside a component.

## beforeRouteEnter(routeTo, routeFrom, next)

This is called before the component is created.  Since the component has not been created yet, we can‚Äôt use the `this` keyword here.

## beforeRouteUpdate(routeTo, routeFrom, next)

This is called when the route changes, but is still using the same component.  An example here is when we paginate, and we switch from page to page but still using the same component.  It does have access to "this".

## beforeRouteLeave(routeTo, routeFrom, next)

This is called when this component is navigated away from. It does have access to "this".

As I mentioned above, each of these methods at some point must call `next()`.  Here‚Äôs what you can do with next:

`**next()**` - Called by itself will continue navigation to `routeTo`.

`**next(false)**` - Cancels the navigation.

`**next('/')**`- Redirects page to the / path.

`**next({ name: 'event-list' })**` - Redirects to this named path

Any options you might put in a `router-link`'s `to` property you can send into `next()` for redirecting navigation.

----------
## beforeRouteLeave Example

If I want to confirm that the user wants to leave the page before saving changes, I might use the following code:

```javascript
    beforeRouteLeave(routeTo, routeFrom, next) {
      const answer = window.confirm(
        'Do you really want to leave? You have unsaved changes!'
      )
      if (answer) {
        next() // <-- Confirms the navigation
      } else {
        next(false) // <-- Cancels the navigation
      }
    },
```
----------
## How might we use these with our EventShow component

At the moment EventShow looks like this:

![](https://firebasestorage.googleapis.com/v0/b/vue-mastery.appspot.com/o/flamelink%2Fmedia%2F1578383670758_0.gif?alt=media&token=69400f5b-3aca-4015-a871-b12fd4e39b26)

Notice that there‚Äôs no progress bar and the tempate shows up on the page before the data gets returned from the API call.  We only want to see the template when the data arrives.

We have three steps to implement our solution:

1. Start the progress bar when routing to the component.
2. Make the API call, using the **fetchEvent** action.
3. When API returns finish progress bar.
4. Render the component template.

Our **EventShow** ****component ****currently looks like this:

üìÉ **/src/views/EventShow.vue**
```javascript
    <script>
    import { mapState, mapActions } from 'vuex'
    
    export default {
      props: ['id'],
      created() {
        this.fetchEvent(this.id)
      },
      computed: mapState({
        event: state => state.event.event
      }),
      methods: mapActions('event', ['fetchEvent'])
    }
    </script>
```
To use NProgress inside of this component, we need to do a few things here:

üìÉ **/src/views/EventShow.vue**
```javascript
    <script>
    import { mapState, mapActions } from 'vuex'
    import NProgress from 'nprogress' // <--- Include the progress bar
    import store from '@/store/store' // <--- Include our Vuex store
    
    export default {
      props: ['id'],
      
      beforeRouteEnter(routeTo, routeFrom, next) {
        NProgress.start() // Start the progress bar
        store.dispatch('event/fetchEvent', routeTo.params.id).then(() => {
          NProgress.done() // When the action is done complete progress bar
          next() // Only once this is called does the navigation continue
        })
      },
      
      computed: mapState({
        event: state => state.event.event
      })
    }
    </script>
```
There‚Äôs a lot going on here, so let‚Äôs break it down.

First, we include NProgress and the Vuex Store. Then we use the `beforeRouteEnter` navigation guard. This guard is called before the component is created, which means it doesn‚Äôt have access to `this` .  That‚Äôs why we needed to import the `store` and why we‚Äôre calling the action explicitly and not using `mapAction`, which I‚Äôve removed.  

We start the progress bar, dispatch the `fetchEvent` Action, and then when the Action is done we finish the progress bar and call `next()`, which tells Vue to continue navigation to this component. Until `next()` is called, the web app is going to wait.

If we look in the browser, we see the progress bar working, but it doesn‚Äôt seem to be waiting for our API call to be finished before finishing the progress bar. What is going on?

![](https://firebasestorage.googleapis.com/v0/b/vue-mastery.appspot.com/o/flamelink%2Fmedia%2F1578383679601_1.gif?alt=media&token=eabfac60-9a0b-4071-95a6-02a1ea19a6ab)


Well, inside our **event** Module, in the `fetchEvent`  action we aren‚Äôt returning anything that we can call `then()` on.  See how the `EventService` isn‚Äôt returned?

üìÉ **/src/store/modules/event.js**
```javascript
    ...
      fetchEvent({ commit, getters, dispatch }, id) {
        var event = getters.getEventById(id)
        if (event) {
          commit('SET_EVENT', event)
        } else {
          EventService.getEvent(id) // <--- No return here!  
            .then(response => {
              commit('SET_EVENT', response.data)
            })
            ...
```
We can add a `return` so that line looks like this:

```javascript
           return EventService.getEvent(id)
```
When we look in our browser, the component now waits until the data is returned before calling `next()` and rendering the component. 

![](https://firebasestorage.googleapis.com/v0/b/vue-mastery.appspot.com/o/flamelink%2Fmedia%2F1578372499186_2.gif?alt=media&token=420156ef-1ef9-4d54-ab94-07a2664e00e7)

Once again we have a valid solution, but there is one more way to do this which I know I liked the most.  If you‚Äôre coding along with us, the next lesson is where you‚Äôll want to follow along.
