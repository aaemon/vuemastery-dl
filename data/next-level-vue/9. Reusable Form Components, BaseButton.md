# Reusable Form Components, BaseButton

In our previous lessons on Reusable Form Components, we built our **BaseInput** and **BaseSelect** components. Now thereâ€™s one final form component weâ€™ll learn how to create: a **BaseButton**. You can use this button component in each of your appâ€™s forms, and weâ€™ll also learn how to make it work for other purposes, outside the context of just forms. So letâ€™s get started.


----------
## Creating BaseButton

Currently in our **EventCreate.vue** file, we are submitting our form with:

ğŸ“ƒ **src/views/EventCreate.vue**
```html
    <input type="submit" class="button -fill-gradient" value="Submit"/>
```
Instead, letâ€™s encapsulate this functionality within a Vue component. Weâ€™ll start with some simple code for itâ€™s template

ğŸ“ƒ **src/components/BaseButton.vue**
```html
    <template>
      <button>
        <slot/> 
      </button>
    </template>
```
As you can see, weâ€™re using a `button` element that has a `slot`.  If slots are unfamiliar to you, check out [this lesson](https://www.vuemastery.com/courses/real-world-vue-js/slots) we made on the topic. In our parent scope, weâ€™ll pass in â€œsubmitâ€ into that slot. 

ğŸ“ƒ **src/views/EventCreate.vue**
```html
    <BaseButton>Submit</BaseButton>
```
We can pass in whatever we need to when using this button component. For example, we could slot-in â€œSendâ€ or â€œMessageâ€ in other parts of our app.


----------
## Getting the Button to Work

Now we need to get our **BaseButton** to submit the form. So I can add `type=``"``submit``"` on it like so:

ğŸ“ƒ **src/views/EventCreate.vue**
```html
    <BaseButton type="submit">Submit</BaseButton>
```
Now, since our form has `<form @submit.prevent="createEvent">` on it, our **BaseButton** works! It submits our form, which creates our event.


----------
## Using BaseButton outside of a Form

While **BaseButton** now works to submit a form, we need to add to it if we want it to work outside the context of a form. For example, **BaseButton** could be used to send a message, which might look like:

```html
    <BaseButton @click="sendMessage">Message</BaseButton>
```
Since weâ€™ve added the `@click` event listener here, we need to share that listener from the parent scope down to the child. The way we can accomplish that is to head into **BaseButton** and inherit those `$listeners` on the native `button` element itself.

ğŸ“ƒ **src/components/BaseButton.vue**
```html
    <template>
      <div>
        <button v-on="$listeners"> <!-- inheriting event listeners -->
          <slot/>
        </button>
      </div>
    </template>
```
Now we can add dynamic event listeners onto **BaseButton**, and the native button inside will be able to â€œhearâ€ those events (such as clicks) when they happen.

Now that our **BaseButton** should work wherever we need it, letâ€™s think about how we can style it.



----------
## Styling BaseButton

Heading down into the `style`  section of BaseButton, weâ€™ll add some local styles. 

ğŸ“ƒ **src/components/BaseButton.vue**
```css
    .button {
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      height: 52px;
      padding: 0 40px;
      background: transparent;
      border: none;
      border-radius: 6px;
      text-align: center;
      font-weight: 600;
      white-space: nowrap;
      transition: all 0.2s linear;
    }
    .button:hover {
      -webkit-transform: scale(1.02);
      transform: scale(1.02);
      box-shadow: 0 7px 17px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
    }
    .button:active {
      -webkit-transform: scale(1);
      transform: scale(1);
      box-shadow: none;
    }
    .button:focus {
      outline: 0;
    }
    .button.-fill-gradient {
      background: linear-gradient(to right, #16c0b0, #84cf6a);
      color: #ffffff;
    }
    .button:disabled {
      -webkit-transform: scale(1);
      transform: scale(1);
      box-shadow: none;
      background: #eeeeee;
    }
    .button + .button {
      margin-left: 1em;
    }
    .button.-fill-gray {
      background: rgba(0, 0, 0, 0.5);
      color: #ffffff;
    }
    .button.-size-small {
      height: 32px;
    }
    .button.-icon-right {
      text-align: left;
      padding: 0 20px;
    }
    .button.-icon-right > .icon {
      margin-left: 10px;
    }
    .button.-icon-left {
      text-align: right;
      padding: 0 20px;
    }
    .button.-icon-left > .icon {
      margin-right: 10px;
    }
    .button.-icon-center {
      padding: 0 20px;
    }
```
Now we have a list of style rule options that we can apply, or not, depending on how **BaseButton** is being used. We want the `.button` class to appear no matter what, so weâ€™ll add that class to the native button element.

ğŸ“ƒ **src/components/BaseButton.vue**
```html
    <template>
      <div>
        <button v-on="$listeners" class="button"> 
          <slot/>
        </button>
      </div>
    </template>
```

----------
## Dynamic Button Styles

Now we need to think about how we can add dynamic styles to our button. You might think that the solution would be to set `inheritAttrs` to `false` like we did in our BaseInput lesson, which allowed us to inherit attributes added on the parent scope. So it would make sense that we could just bind those attributes right onto the native `button` element, like:


![](https://firebasestorage.googleapis.com/v0/b/vue-mastery.appspot.com/o/flamelink%2Fmedia%2F1578372532765_0.png?alt=media&token=22c14d35-b393-4f58-bec8-5fc3e7f6920e)


However, this isnâ€™t currently how Vue works. As of now, the `class` and `style` attributes arenâ€™t available to you on `$attrs`. However, we can expect that to change in Vue 3. 

So if we canâ€™t `v-bind` to our `$attrs`, how can we apply a dynamic class to our **BaseButton**? We can use props for that.

ğŸ“ƒ **src/components/BaseButton.vue**
```javascript
    <template>
      <div>
        <button v-on="$listeners" class="button" :class="buttonClass">
          <slot/>
        </button>
      </div>
    </template>
    <script>
    export default {
      props: {
        buttonClass: {
          type: String
        }
      }
    }
    </script>
```
Now we have a `buttonClass` prop that weâ€™ve bound to the `button`. This means we can now pass through class names from the parent scope, like our class of `-fill-gradient`.

ğŸ“ƒ **src/views/EventCreate.vue**
```html
    <BaseButton type="submit" buttonClass="-fill-gradient">Submit</BaseButton>
```

----------
## We still want to Inherit Attributes

Even though `class` and `style` arenâ€™t currently available t us in `$attrs`, weâ€™ll still want to be inheriting attributes because we still want to have the ability to inherit attributes added on the parent scope, such as `disabled`.

For example:

```html
    <BaseButton type="submit" buttonClass="-fill-gradient" disabled>Submit</BaseButton>
```
So weâ€™ll add the ability to inherit attributes to **BaseButton** now.

ğŸ“ƒ **src/components/BaseButton.vue**
```javascript
    <template>
      <div>
        <button v-on="$listeners" v-bind="$attrs" class="button" :class="buttonClass"> <!-- inheriting attributes here -->
          <slot/>
        </button>
      </div>
    </template>
    <script>
    export default {
      inheritAttrs: false, <!-- turns off default inheriting behavior -->
      props: {
        buttonClass: {
          type: String
        }
      }
    }
    </script>
```

----------
## We did it!

Great! Now **BaseButton** is ready to be used anywhere itâ€™s needed throughout our app.

Hereâ€™s the complete code:

ğŸ“ƒ **src/components/BaseButton.vue**
```javascript
    <template>
      <div>
        <button v-on="$listeners" v-bind="$attrs" class="button" :class="buttonClass">
          <slot/>
        </button>
      </div>
    </template>
    <script>
    export default {
      inheritAttrs: false,
      props: {
        buttonClass: {
          type: String
        }
      }
    }
    </script>
    <style scoped>
    .button {
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      height: 52px;
      padding: 0 40px;
      background: transparent;
      border: none;
      border-radius: 6px;
      text-align: center;
      font-weight: 600;
      white-space: nowrap;
      transition: all 0.2s linear;
    }
    .button:hover {
      -webkit-transform: scale(1.02);
      transform: scale(1.02);
      box-shadow: 0 7px 17px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
    }
    .button:active {
      -webkit-transform: scale(1);
      transform: scale(1);
      box-shadow: none;
    }
    .button:focus {
      outline: 0;
    }
    .button.-fill-gradient {
      background: linear-gradient(to right, #16c0b0, #84cf6a);
      color: #ffffff;
    }
    .button:disabled {
      -webkit-transform: scale(1);
      transform: scale(1);
      box-shadow: none;
      background: #eeeeee;
    }
    .button + .button {
      margin-left: 1em;
    }
    .button.-fill-gray {
      background: rgba(0, 0, 0, 0.5);
      color: #ffffff;
    }
    .button.-size-small {
      height: 32px;
    }
    .button.-icon-right {
      text-align: left;
      padding: 0 20px;
    }
    .button.-icon-right > .icon {
      margin-left: 10px;
    }
    .button.-icon-left {
      text-align: right;
      padding: 0 20px;
    }
    .button.-icon-left > .icon {
      margin-right: 10px;
    }
    .button.-icon-center {
      padding: 0 20px;
    }
    </style>
```

----------
## Whatâ€™s next?

Now that weâ€™ve built our reusable form components, in the next lesson weâ€™ll start learning how to add validation to our forms, so they canâ€™t be submitted if theyâ€™ve been filled out incorrectly.
